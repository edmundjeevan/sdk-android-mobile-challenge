package com.anypresence.anypresence_inc.citi_mobile_challenge.dao;

import com.anypresence.anypresence_inc.citi_mobile_challenge.dao.DaoSession;
import de.greenrobot.dao.DaoException;

// THIS CODE IS GENERATED BY greenDAO, EDIT ONLY INSIDE THE "KEEP"-SECTIONS

// KEEP INCLUDES - put your custom includes here
// KEEP INCLUDES END
/**
 * Entity mapped to table RETAILBANKINGACCOUNTBALANCES.
 */
public class RetailBankingAccountBalance extends APObject {

	private Long id;
	private String accountId;
	private String balanceType;
	private Integer value;
	private String scope;
	private String objectId;
	private java.util.Date _cacheUpdatedAt;
	private Long apCachedRequestId;

	/** Used to resolve relations */
	private transient DaoSession daoSession;

	/** Used for active entity operations. */
	private transient RetailBankingAccountBalanceDao myDao;

	private APCachedRequest aPCachedRequest;
	private Long aPCachedRequest__resolvedKey;

	// KEEP FIELDS - put your custom fields here
	// KEEP FIELDS END

	public RetailBankingAccountBalance() {
	}

	public RetailBankingAccountBalance(Long id) {
		this.id = id;
	}

	public RetailBankingAccountBalance(Long id, String accountId,
			String balanceType, Integer value, String scope, String objectId,
			java.util.Date _cacheUpdatedAt, Long apCachedRequestId) {
		this.id = id;
		this.accountId = accountId;
		this.balanceType = balanceType;
		this.value = value;
		this.scope = scope;
		this.objectId = objectId;
		this._cacheUpdatedAt = _cacheUpdatedAt;
		this.apCachedRequestId = apCachedRequestId;
	}

	/** called by internal mechanisms, do not call yourself. */
	public void __setDaoSession(DaoSession daoSession) {
		this.daoSession = daoSession;
		myDao = daoSession != null ? daoSession
				.getRetailBankingAccountBalanceDao() : null;
	}

	public Long getId() {
		return id;
	}

	public void setId(Long id) {
		this.id = id;
	}

	public String getAccountId() {
		return accountId;
	}

	public void setAccountId(String accountId) {
		this.accountId = accountId;
	}

	public String getBalanceType() {
		return balanceType;
	}

	public void setBalanceType(String balanceType) {
		this.balanceType = balanceType;
	}

	public Integer getValue() {
		return value;
	}

	public void setValue(Integer value) {
		this.value = value;
	}

	public String getScope() {
		return scope;
	}

	public void setScope(String scope) {
		this.scope = scope;
	}

	public String getObjectId() {
		return objectId;
	}

	public void setObjectId(String objectId) {
		this.objectId = objectId;
	}

	public java.util.Date get_cacheUpdatedAt() {
		return _cacheUpdatedAt;
	}

	public void set_cacheUpdatedAt(java.util.Date _cacheUpdatedAt) {
		this._cacheUpdatedAt = _cacheUpdatedAt;
	}

	public Long getApCachedRequestId() {
		return apCachedRequestId;
	}

	public void setApCachedRequestId(Long apCachedRequestId) {
		this.apCachedRequestId = apCachedRequestId;
	}

	/** To-one relationship, resolved on first access. */
	public APCachedRequest getAPCachedRequest() {
		Long __key = this.apCachedRequestId;
		if (aPCachedRequest__resolvedKey == null
				|| !aPCachedRequest__resolvedKey.equals(__key)) {
			if (daoSession == null) {
				throw new DaoException("Entity is detached from DAO context");
			}
			APCachedRequestDao targetDao = daoSession.getAPCachedRequestDao();
			APCachedRequest aPCachedRequestNew = targetDao.load(__key);
			synchronized (this) {
				aPCachedRequest = aPCachedRequestNew;
				aPCachedRequest__resolvedKey = __key;
			}
		}
		return aPCachedRequest;
	}

	public void setAPCachedRequest(APCachedRequest aPCachedRequest) {
		synchronized (this) {
			this.aPCachedRequest = aPCachedRequest;
			apCachedRequestId = aPCachedRequest == null
					? null
					: aPCachedRequest.getId();
			aPCachedRequest__resolvedKey = apCachedRequestId;
		}
	}

	/** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
	public void delete() {
		if (myDao == null) {
			throw new DaoException("Entity is detached from DAO context");
		}
		myDao.delete(this);
	}

	/** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
	public void update() {
		if (myDao == null) {
			throw new DaoException("Entity is detached from DAO context");
		}
		myDao.update(this);
	}

	/** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
	public void refresh() {
		if (myDao == null) {
			throw new DaoException("Entity is detached from DAO context");
		}
		myDao.refresh(this);
	}

	// KEEP METHODS - put your custom methods here
	// KEEP METHODS END

}
